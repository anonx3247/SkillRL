---
phase: 01-foundation-agent-loop
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/environment/env_manager.py
  - src/environment/actions.py
  - src/environment/server.py
  - src/environment/__init__.py
autonomous: true

must_haves:
  truths:
    - "ALFWorld environment loads and resets to individual tasks"
    - "All 10 action tools plus task_completed are callable via FastMCP"
    - "Tool calls return natural language observation strings only"
    - "Environment state persists across tool calls within a single task"
  artifacts:
    - path: "src/environment/env_manager.py"
      provides: "ALFWorld lifecycle management -- load, reset, step, done detection"
      exports: ["EnvManager"]
    - path: "src/environment/actions.py"
      provides: "11 FastMCP tool functions (10 actions + task_completed)"
      contains: "@mcp.tool"
    - path: "src/environment/server.py"
      provides: "FastMCP server instance and tool registration"
      exports: ["mcp", "env_manager"]
  key_links:
    - from: "src/environment/actions.py"
      to: "src/environment/env_manager.py"
      via: "env_manager.step() calls inside each tool"
      pattern: "env_manager\\.step"
    - from: "src/environment/server.py"
      to: "src/environment/actions.py"
      via: "imports actions module to register tools on mcp instance"
      pattern: "import.*actions"
---

<objective>
Wrap ALFWorld as a FastMCP tool server exposing all 11 tools (go_to, take, put, open, close, clean, heat, cool, use, examine, inventory, task_completed).

Purpose: Creates the environment interface that the agent loop (Plan 03) will interact with. The agent calls tools, tools call ALFWorld, observations flow back as natural language strings.
Output: FastMCP server with ALFWorld environment lifecycle management and all action tools.
</objective>

<execution_context>
@/Users/anas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-agent-loop/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ALFWorld environment manager</name>
  <files>
    src/environment/env_manager.py
  </files>
  <action>
    Create src/environment/env_manager.py with an EnvManager class that wraps ALFWorld:

    Class `EnvManager`:
    - `__init__(self, split: str = "eval_out_of_distribution")`: Store split, set env=None, current_task_id=None, done=False, score=0.
    - `load(self)`: Load ALFWorld config via `alfworld.agents.modules.generic.load_config()`, get environment type from config, create environment with `get_environment(env_type)(config, train_eval=split)`, call `env.init_env(batch_size=1)`. Store env on self. Return self for chaining.
    - `reset(self) -> tuple[str, dict]`: Call `self.env.reset()`, extract observation (first element if list/batch), reset done/score state. Store admissible_commands from info if available. Return (observation_string, info_dict).
    - `step(self, action: str) -> tuple[str, float, bool, dict]`: Call `self.env.step([action])` (ALFWorld expects batch input), extract first element from each return. Update self.done and self.score. Return (observation, score, done, info).
    - `get_task_type(self) -> str`: Parse task type from environment info. ALFWorld task types map to: pick_and_place_simple -> "pick", look_at_obj_in_light -> "look", pick_clean_then_place_in_recep -> "clean", pick_heat_then_place_in_recep -> "heat", pick_cool_then_place_in_recep -> "cool", pick_two_obj_and_place -> "pick2". Extract from self.env or info dict. Use the gamefile path to determine type if needed.
    - `get_task_id(self) -> str`: Return a unique identifier for the current task (e.g., from gamefile path or sequential index).

    IMPORTANT: ALFWorld returns batched results (lists) even with batch_size=1. Always index [0] to get the single result.
    IMPORTANT: Use module-level or class-level init, NOT FastMCP lifespan (bug #1115 -- lifespan runs per-request).
    IMPORTANT: ALFWorld observations are natural language strings by default. No special config needed for text mode.
  </action>
  <verify>
    Run:
    ```
    python -c "
    from src.environment.env_manager import EnvManager
    em = EnvManager()
    em.load()
    obs, info = em.reset()
    print(f'Observation type: {type(obs).__name__}')
    print(f'Observation: {obs[:200]}')
    assert isinstance(obs, str), 'Observation must be string'
    print('env_manager OK')
    "
    ```
    This should load ALFWorld, reset to a task, and print a natural language observation string.
  </verify>
  <done>EnvManager loads ALFWorld, resets to tasks, steps with actions, and returns natural language observation strings. Batch indexing handled correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create FastMCP server with all 11 action tools</name>
  <files>
    src/environment/server.py
    src/environment/actions.py
    src/environment/__init__.py
  </files>
  <action>
    Create src/environment/server.py:
    - Instantiate `FastMCP(name="ALFWorldServer")` as module-level `mcp`
    - Instantiate `EnvManager()` as module-level `env_manager` (do NOT call .load() here -- let the caller do it when ready)
    - Import actions module to register tools: `from src.environment import actions`
    - Export mcp and env_manager

    Create src/environment/actions.py with all 11 tools registered on the mcp instance:

    Import mcp and env_manager from server.py. For each tool, use @mcp.tool decorator.

    The 10 environment action tools (each calls env_manager.step with the appropriate ALFWorld command string):
    1. `go_to(location: str) -> str` -- "go to {location}"
    2. `take(object_name: str) -> str` -- "take {object_name}"
    3. `put(object_name: str, receptacle: str) -> str` -- "put {object_name} in/on {receptacle}"
    4. `open_receptacle(receptacle: str) -> str` -- "open {receptacle}" (name it open_receptacle, not open, to avoid shadowing Python builtin)
    5. `close_receptacle(receptacle: str) -> str` -- "close {receptacle}"
    6. `clean(object_name: str, receptacle: str) -> str` -- "clean {object_name} with {receptacle}"
    7. `heat(object_name: str, receptacle: str) -> str` -- "heat {object_name} with {receptacle}"
    8. `cool(object_name: str, receptacle: str) -> str` -- "cool {object_name} with {receptacle}"
    9. `use(object_name: str) -> str` -- "use {object_name}"
    10. `examine(object_name: str) -> str` -- "examine {object_name}"
    11. `inventory() -> str` -- "inventory"

    Plus the meta tool:
    12. `task_completed(success: bool, summary: str) -> str` -- Does NOT call env_manager.step. Instead, returns a formatted completion string and sets a flag on env_manager (add `task_completed_flag: bool` and `task_completed_success: bool | None` and `task_completed_summary: str | None` to EnvManager). This tool signals the agent loop to stop.

    Each action tool MUST:
    - Have a clear docstring describing what it does (this becomes the tool description for the LLM)
    - Have typed parameters with descriptive names
    - Return only the observation string from env_manager.step()
    - NOT include ALFWorld internal state, scores, or done flags in the return

    IMPORTANT: Use descriptive parameter names that help the LLM understand what to pass (e.g., "receptacle" not "target").
    IMPORTANT: For put/clean/heat/cool that take two args, match ALFWorld's expected command format exactly.
    IMPORTANT: The function name is what becomes the tool name the LLM sees. Name them to match the research prompt exactly: go_to, take, put, open_receptacle (LLM will see "open_receptacle"), close_receptacle, clean, heat, cool, use, examine, inventory, task_completed.

    Update src/environment/__init__.py to export mcp, env_manager from server.

    NOTE on circular imports: server.py creates mcp + env_manager, actions.py imports them from server.py and registers tools. server.py imports actions at module level AFTER mcp/env_manager are defined. This is fine as long as actions.py doesn't import from __init__.py.
  </action>
  <verify>
    Run:
    ```
    python -c "
    from src.environment.server import mcp, env_manager
    tools = mcp._tool_manager.tools if hasattr(mcp, '_tool_manager') else {}
    tool_names = list(tools.keys()) if tools else []
    # If tool listing API differs, try mcp.list_tools() or inspect mcp
    print(f'Registered tools: {len(tool_names)}')
    print(f'Tool names: {sorted(tool_names)}')
    assert len(tool_names) >= 11, f'Expected 11+ tools, got {len(tool_names)}'
    print('FastMCP server OK')
    "
    ```
    If the internal API for listing tools differs, adapt the check. The key assertion: at least 11 tools registered.

    Then test an actual tool call:
    ```
    python -c "
    import asyncio
    from src.environment.server import mcp, env_manager
    env_manager.load()
    obs, info = env_manager.reset()
    print(f'Task: {obs[:150]}')
    # Test a step
    obs2, score, done, info2 = env_manager.step('inventory')
    print(f'Inventory: {obs2}')
    assert isinstance(obs2, str)
    print('tool execution OK')
    "
    ```
  </verify>
  <done>FastMCP server has 11+ registered tools (go_to, take, put, open_receptacle, close_receptacle, clean, heat, cool, use, examine, inventory, task_completed). Each action tool calls env_manager.step and returns natural language strings. task_completed sets a flag without calling env_manager.step.</done>
</task>

</tasks>

<verification>
1. EnvManager loads ALFWorld and returns natural language observations
2. All 11 tools registered on FastMCP server
3. Action tools call env_manager.step() and return observation strings
4. task_completed tool sets completion flag without stepping environment
5. No privileged state information leaks through tool returns
</verification>

<success_criteria>
- EnvManager.load() initializes ALFWorld eval_out_of_distribution environment
- EnvManager.reset() returns (observation: str, info: dict)
- EnvManager.step(action) returns (observation: str, score: float, done: bool, info: dict) with batch indexing
- 11 tools registered on FastMCP mcp instance
- Each tool has typed parameters and descriptive docstring
- tool returns are pure natural language strings
- task_completed sets flag on env_manager, does not call step()
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-agent-loop/01-02-SUMMARY.md`
</output>
