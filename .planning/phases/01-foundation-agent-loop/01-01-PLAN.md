---
phase: 01-foundation-agent-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/__init__.py
  - src/trajectory/__init__.py
  - src/trajectory/models.py
  - src/trajectory/storage.py
autonomous: true

must_haves:
  truths:
    - "Trajectory dataclasses capture step-level thought, action, observation plus task-level outcome"
    - "Trajectories persist to JSONL files with atomic writes that survive crashes"
    - "Project installs cleanly with all Phase 1 dependencies"
  artifacts:
    - path: "pyproject.toml"
      provides: "Project metadata and all Phase 1 dependencies"
      contains: "fastmcp"
    - path: "src/trajectory/models.py"
      provides: "Step and Trajectory dataclasses"
      exports: ["Step", "Trajectory"]
    - path: "src/trajectory/storage.py"
      provides: "JSONL append with atomic write-fsync-rename"
      exports: ["append_trajectory", "load_trajectories"]
  key_links:
    - from: "src/trajectory/storage.py"
      to: "src/trajectory/models.py"
      via: "import and asdict serialization"
      pattern: "from.*models.*import.*Trajectory"
---

<objective>
Set up the Python project structure and implement trajectory data models with crash-resilient JSONL persistence.

Purpose: Establishes the project foundation that all other plans build on -- dependency management, package structure, and the trajectory capture system needed by the agent loop (Plan 03).
Output: Installable Python package with trajectory Step/Trajectory dataclasses and atomic JSONL storage.
</objective>

<execution_context>
@/Users/anas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-agent-loop/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project structure and install dependencies</name>
  <files>
    pyproject.toml
    src/__init__.py
    src/trajectory/__init__.py
    src/environment/__init__.py
    src/agent/__init__.py
  </files>
  <action>
    Create pyproject.toml with:
    - name: "skillrl"
    - python: ">=3.11"
    - dependencies: fastmcp>=2.14.5,<3; openai>=1.0; alfworld; tenacity; pydantic>=2.0
    - dev dependencies: pytest; pytest-asyncio
    - Build system: setuptools with pyproject.toml

    Create src/__init__.py (empty), src/trajectory/__init__.py, src/environment/__init__.py, src/agent/__init__.py (all empty marker files).

    Run `pip install -e ".[dev]"` to install the project in editable mode. If alfworld has install issues, install it separately with `pip install alfworld` first.

    IMPORTANT: Do NOT use poetry or hatch -- plain setuptools with pyproject.toml. Keep it simple.
  </action>
  <verify>
    Run `python -c "import fastmcp; import openai; import tenacity; print('deps ok')"` -- should print "deps ok".
    Run `pip list | grep -i skillrl` -- should show skillrl installed in editable mode.
  </verify>
  <done>Project installs cleanly with all dependencies. All package directories exist with __init__.py files.</done>
</task>

<task type="auto">
  <name>Task 2: Implement trajectory data models and JSONL storage</name>
  <files>
    src/trajectory/models.py
    src/trajectory/storage.py
    src/trajectory/__init__.py
  </files>
  <action>
    Create src/trajectory/models.py with two dataclasses:

    1. `Step` dataclass:
       - step: int (0-indexed step number)
       - thought: str | None (model's reasoning text, None if direct tool call)
       - action: str (tool name called)
       - action_input: str (JSON string of tool arguments)
       - observation: str (tool result / environment response)
       - timestamp: float (epoch seconds, default via field factory)

    2. `Trajectory` dataclass:
       - task_id: str (ALFWorld task identifier)
       - task_description: str (the natural language task prompt)
       - task_type: str (one of: pick, look, clean, heat, cool, pick2)
       - success: bool (whether task was completed successfully)
       - steps: list[Step] (all steps taken)
       - total_steps: int (len of steps)
       - duration_seconds: float (wall clock time)
       - failure_reason: str | None (set if success=False -- "timeout", "no_tool_call", "agent_declared_failure")
       - env_done: bool (ALFWorld's own done flag for discrepancy detection)
       - Add to_dict() method that uses dataclasses.asdict()

    Use standard dataclasses, NOT Pydantic (performance -- research says 10-100x slower for internal data).
    Use `from __future__ import annotations` for modern type syntax.

    Create src/trajectory/storage.py with two functions:

    1. `append_trajectory(trajectory: Trajectory, output_path: Path) -> None`:
       - Serialize trajectory to JSON via asdict()
       - Write as single line to JSONL file
       - Use atomic write pattern: write to .tmp file, flush, fsync, then os.replace() (not rename -- replace is cross-platform atomic)
       - Create parent directories if they don't exist (parents=True, exist_ok=True)
       - IMPORTANT: For append, read existing file content first, append new line, write all to temp, then replace. This preserves existing data atomically.

    2. `load_trajectories(input_path: Path) -> list[Trajectory]`:
       - Read JSONL file line by line
       - Deserialize each line to dict, then construct Trajectory (with nested Step objects)
       - Skip blank lines
       - Return list of Trajectory objects
       - Return empty list if file doesn't exist

    Update src/trajectory/__init__.py to export Step, Trajectory, append_trajectory, load_trajectories.
  </action>
  <verify>
    Run a quick inline test:
    ```
    python -c "
    from src.trajectory.models import Step, Trajectory
    from src.trajectory.storage import append_trajectory, load_trajectories
    from pathlib import Path
    import tempfile, os

    # Create test trajectory
    s = Step(step=0, thought='I should go to desk', action='go_to', action_input='{\"location\": \"desk 1\"}', observation='You see a desk.')
    t = Trajectory(task_id='test-1', task_description='Find pen', task_type='pick', success=True, steps=[s], total_steps=1, duration_seconds=1.5, failure_reason=None, env_done=True)

    # Write and read back
    p = Path(tempfile.mkdtemp()) / 'test.jsonl'
    append_trajectory(t, p)
    append_trajectory(t, p)  # append second
    loaded = load_trajectories(p)
    assert len(loaded) == 2, f'Expected 2, got {len(loaded)}'
    assert loaded[0].task_id == 'test-1'
    assert loaded[0].steps[0].action == 'go_to'
    print('trajectory storage OK')
    "
    ```
  </verify>
  <done>Step and Trajectory dataclasses exist with all required fields. append_trajectory writes atomically to JSONL. load_trajectories reads back with full fidelity including nested Steps. Two append calls produce two lines that both load correctly.</done>
</task>

</tasks>

<verification>
1. `pip install -e ".[dev]"` completes without errors
2. `python -c "from src.trajectory import Step, Trajectory, append_trajectory, load_trajectories; print('imports ok')"` succeeds
3. Round-trip test (write + read trajectory) passes with correct data
</verification>

<success_criteria>
- pyproject.toml declares all Phase 1 dependencies and project installs in editable mode
- Step dataclass has: step, thought, action, action_input, observation, timestamp
- Trajectory dataclass has: task_id, task_description, task_type, success, steps, total_steps, duration_seconds, failure_reason, env_done
- JSONL storage uses atomic write (temp + fsync + replace) pattern
- Round-trip serialization preserves all fields including nested Step objects
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-agent-loop/01-01-SUMMARY.md`
</output>
